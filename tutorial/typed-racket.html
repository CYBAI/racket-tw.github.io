<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>typed/racket</title>
  <link rel="stylesheet" type="text/css" href="/styles.css" />
</head>
<body>
<root><h1>typed/racket</h1>

雖說 Racket 之中語法並沒有很重要，但還是需要認識裡面常用的 dialect，這篇就是要介紹 typed/racket 這個 dialect。
typed/racket 顧名思義就是標註了 type 的 racket，與 racket/base 的語法基本相通，但加入了一些型別標註(annotation)的語法以及給予某些變體幫助使用者寫出更簡潔的程式(雖然這還蠻看人的那些語法)。

<h3>常見的型別</h3>

我們可以先來觀察說到底有哪些常見 type 可以用：

<div class="highlight"><pre><code>#lang typed/racket

; 值 : Type
"string" : String
#\a : Char
#t : Boolean [more precisely: True]
#f : False
'f : Symbol [more precisely: 'f]
0 : Integer [more precisely: Zero]
1 : Integer [more precisely: Positive-Byte]</code></pre></div>

可以看到一個奇特現象是 racket 的 type 經常有所謂的 more precisely 的標記，來說明存在更精確的型別存在，實際上怎麼做到的這裡不提，但這麼做的理由是為了支持所謂的 type refinement，可以讓 type checker 根據需要限縮型別。除此之外所有的值都可以是自己的 type: <div class="highlight"><pre><code>(ann 1 1)</code></pre></div> 是合法的標註。

<h3>函數類型</h3>

我們用 <a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._-~3e))" class="rkt-docs"><code>-&gt;</code></a> 這個 type constructor 建構函數類型，這在數學上的意思是蘊含，A-&gt;B 代表 A 蘊含 B，racket 裡照慣例用了前綴表達法 (-&gt; A B)，只要 A B 都是類型,則 (-&gt; A B) 是類型。
所以下列都是合法的類型：

<div class="highlight"><pre><code>(-&gt; Number Number Number)
(-&gt; String String Boolean)</code></pre></div>

對應 <a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._define))" class="rkt-docs"><code>define</code></a>，typed/racket 提供了 <a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" class="rkt-docs"><code>:</code></a> 作為宣告型別的語法：

<div class="highlight"><pre><code>(: add (-&gt; Number Number Number))
(define (add x y)
  (+ x y))
(: same (-&gt; String String Boolean))
(define (same s1 s2)
  (eqv? s1 s2))</code></pre></div>

然而也提供了修改過的 <a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._define))" class="rkt-docs"><code>define</code></a>：

<div class="highlight"><pre><code>(define (add [x : Number]
             [y : Number])
  : Number
  (+ x y))
(define (same [s1 : String]
              [s2 : String])
  : Boolean
  (eqv? s1 s2))</code></pre></div>

這些語法可以大部分的情況了，但 racket 本身允許可選參數的存在，在 typed/racket 中就對應了 <a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._-~3e*))" class="rkt-docs"><code>-&gt;*</code></a> 這個 type constructor：

<div class="highlight"><pre><code>(: eval (-&gt;* (Term) (Env) Value))
(define (eval term [env '()])
  ;;; ignore
  )</code></pre></div>

p.s. 根據我目前所知，<a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._-~3e*))" class="rkt-docs"><code>-&gt;*</code></a> 必須明確的寫成 declare/define 分開的形式，寫成 <a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._define))" class="rkt-docs"><code>define</code></a> 內涵型別定義的 form 時 type checker 還是會覺得 optional argument 沒被填上是 type mismatching。

<p></p>

而 racket 本來就支援 <a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._case-lambda))" class="rkt-docs"><code>case-lambda</code></a>(aka function overloading)，所以 typed/racket 也需要處理這個情況：

<div class="highlight"><pre><code>(: append (All (a) (case-&gt;
                     [(Listof a) a -&gt; (Listof a)]
                     [(Listof a) (Listof a) -&gt; (Listof a)])))
;;; 直接定義
(define append2
  (case-lambda #:forall (a)
    [([l : (Listof a)]
      [x : a])
     (append l (list x))]
    [([l1 : (Listof a)]
      [l2 : (Listof a)])
     (append l1 l2)]))</code></pre></div>

<a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._case-~3e))" class="rkt-docs"><code>case-&gt;</code></a> 只有在 <a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._require/typed))" class="rkt-docs"><code>require/typed</code></a> 的時候能用，不然參數想同的情況下 typed/racket 會把 x 被推導成 (U (Listof a) a)。

<p></p>

有趣(麻煩)的最後一點是 keyword argument：

<div class="highlight"><pre><code>(: position (-&gt;* (#:line Integer #:column Integer #:filename String) (#:msg String) Position))
(define (position #:line line #:column column #:filename filename #:msg [msg ""])
  ;;; ignore
  )</code></pre></div>

一般形式的 keyword argument 應該不是什麼大問題，但 optional keyword argument 要注意 pre-binding 不能把 keyword 自己綁進去，而是要把它的對應變數包進去。

<h3>struct</h3>

struct 必定會引入新的型別，並且使用 nominal subtyping，下面提供一個 struct 的簡單案例：

<div class="highlight"><pre><code>(struct point
  ([x : Real]
   [y : Real]))</code></pre></div>

現在表達式 (point 1 2) 的型別就會是 point，<a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._struct))" class="rkt-docs"><code>struct</code></a> 可以有 super type：

<div class="highlight"><pre><code>(struct dog animal ())</code></pre></div>

這樣 dog 也可以是 animal，因為 animal 是 dog 的 super type。

<h3>union type</h3>

為了讓許多原先存在於 racket 的概念運作，也是為了更複雜的應用，typed/racket 提供了 union type，語法 (U a b c) 代表 這個型別可能是 a b 或 c：

<div class="highlight"><pre><code>(let ([n 10])
  (if (even? n)
    'is-even
    'is-odd))</code></pre></div>

這個表達式的型別就是 Symbol [more precisely: (U 'is-even 'is-odd)] (值自己一定是自己的型別)

<h3>recursive type</h3>

type 之間互相參照就叫做 recursive type，在 typed/racket 裡頭可以用 <a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.U))" class="rkt-docs"><code>U</code></a> 與 <a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed/racket/base..rkt)._define-type))" class="rkt-docs"><code>define-type</code></a> 來達成這個效果：

<div class="highlight"><pre><code>(define-type BinaryTree (U Number (Pair BinaryTree BinaryTree)))

(define-type Tree (U leaf node))
(struct leaf ([val : Number]))
(struct node ([left : Tree] [right : Tree]))</code></pre></div>

當然我們不可以直接參照自己：

<div class="highlight"><pre><code>(define-type A A)
(define-type B (U Number B))</code></pre></div>

以上都是 invalid type。

<h3>polymorphism</h3>

polymorphism 或是有些人只聽過 generic，我不打算分清楚他們的差別，以免讀者陷在定義上，這裏主要說的是參數多型，與 <a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._struct))" class="rkt-docs"><code>struct</code></a> 那邊的 super type 不同，
現在先看一個簡單的範例：

<div class="highlight"><pre><code>(define-type (Opt a) (U None (Some a)))
(struct None ())
(struct (a) Some ([v : a]))</code></pre></div>

這個型別可以用來表達可能有值也可能沒有值的情況。函數一樣可以接受不定型別作為參數：

<div class="highlight"><pre><code>(: list-length (All (A) (-&gt; (Listof A) Integer)))
(define (list-length lst)
  (if (null? lst)
    0
    (+ 1 (list-length (cdr lst)))))</code></pre></div>

<a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.All))" class="rkt-docs"><code>All</code></a> 對應邏輯裡面的 <a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._~e2~88~80))" class="rkt-docs"><code>∀</code></a> 符號，意思是對所有 A 都成立。

<h3>inst/ann</h3>

<h4>ann</h4>

ann 是 annotation 的縮寫，用來標記表達式 (expression) 的型別是什麼，總計有三種寫法：

<div class="highlight"><pre><code>(let ([#{x : Number} 7]) x)
(ann x Number)
#:{x :: Number}</code></pre></div>

由於 typed/racket 有 precisely type，所以用 annotation 有時候是有需要的(笑)。

<h4>inst</h4>

而 inst 就更重要了，為了基於 racket 許多內建的 case-lambda 跟 polymorphism function 上，有時候會遇到 type checker 沒辦法推導出正確型別的情況，這時候就需要 inst 提供 type argument 實例化 type：

<div class="highlight"><pre><code>;;; 這會撞到 Polymorphic function `foldl' could not be applied to arguments
(foldl cons null (list 1 2 3 4))
;;; 解法
(foldl (cons Integer Integer) null (list 1 2 3 4))</code></pre></div>

<h3>interaction</h3>

使用 typed/racket，如果函式庫作者沒有提供 type definition 難道就沒救了嗎？這就是最後一塊拼圖，typed/racket 允許使用者提供型別定義：

<div class="highlight"><pre><code>(require/typed "point.rkt"
  [#:struct point ([x : Real] [y : Real])]
  [distance (-&gt; point point Real)])</code></pre></div>

這樣一來使用者就不需要綁死在 racket 或是 typed/racket 上，而是能夠按需要選擇適合的語言了。

<h3>總結</h3>

希望這些可以讓讀者開始使用 typed/racket 增強需要型別檢查的部分，如果覺得有哪些資訊也應該放進這篇裡面可以寄信(dannypsnl@gmail.com)告訴我，
如果有想了解的內容但還沒有相關教學可以 <a href="https://github.com/racket-tw/racket-tw.github.io/issues/new">開新 issue</a>。

<p></p>

<a href="https://github.com/dannypsnl">Lîm Tsú-thuàn</a> 編輯
</root>
<p><p/>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="創用 CC 授權條款" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" /></a><br />本著作係採用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">創用 CC 姓名標示-非商業性-禁止改作 4.0 國際 授權條款</a>授權.
</body>
</html>